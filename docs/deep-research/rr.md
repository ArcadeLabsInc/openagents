Running React Router v7 with Express and Rust on DigitalOcean App Platform

Multi-Backend Architecture on DigitalOcean App Platform

DigitalOcean App Platform supports multiple services (components) in a single application, which is ideal for running both an Express (Node.js) server and a Rust (Axum) server side by side. You can configure path-based routing so that requests are directed to the appropriate backend service. For example, you might route yourdomain.com/api/v1 to the Express component and yourdomain.com/api/v2 to the Axum component ￼. Each component runs in its own container and can scale independently, but they share the same top-level domain when using this approach. DigitalOcean’s platform will handle load balancing across instances of each service, and it treats containers as stateless and interchangeable ￼, so design your Express and Axum apps to be stateless (e.g. use external storage for sessions or caching) for best scalability.

To set this up, you can add both services to a single DigitalOcean App. In the App Spec (YAML or via the control panel), define two components (one for Node, one for Rust) and use ingress rules or HTTP routes to map URL paths to each service. For instance, you can map the root of your domain (/) to the frontend and /api (or more granular prefixes) to your backend APIs ￼. DigitalOcean’s example suggests having the custom domain pointing to the frontend component and an /api sub-path pointing to the backend API component ￼. Under the hood, the platform ensures that requests hitting /api/... are forwarded to the Express or Rust service (depending on how you partition routes). This way, both backends can run separately but appear under one unified domain.

It’s also possible to keep the code in a monorepo and have the App Platform build each component from different subdirectories. You can specify a source_dir for each component in the app spec to point to the Express app folder and the Rust project folder respectively ￼. Each service can have its own build and run commands. The App Platform can either use its built-in build system (e.g. Node.js environment for Express, or a Dockerfile for Rust) or you can provide custom Dockerfiles for one or both services (discussed more below). The key point is that the App Platform allows you to deploy these as one application for easier management, while keeping them as separate services with their own API routes.

Serving the React Frontend (React Router v7 SPA)

Your React application (built with React Router v7) is a single-page application (SPA), which means it handles routing on the client side. When deploying such an app, you need to ensure that any unknown route requests are served the main index.html so that the React app can take over. There are a few ways to serve the React frontend in this architecture:
• Using a Static Site Component (Recommended): DigitalOcean App Platform can host static frontends separately, and you can deploy your compiled React app as a static site. This approach has the advantage of a global CDN and free hosting tier for static sites ￼. You would build your React app (e.g. using npm run build or Vite) and have the static files (HTML, JS, CSS) deployed. In the App Platform settings for the static site, enable a catch-all or “Catchall Document” setting to point to index.html for all unmatched routes ￼. This ensures that refreshing or navigating directly to any React Router route (like /dashboard or /profile) returns the main HTML page instead of a 404 error. The platform added support for this SPA routing: you can specify a Catchall file (usually index.html) so that any 404 on the static site will serve that file with a 200 OK ￼. With this setup, the React app is decoupled from the backends and served efficiently via CDN.
• Serving Static Files from Express: If you prefer to have the Node/Express server serve the React app, you can do so by copying the React build output into the Express app (or building it there). Express can use express.static() middleware to serve the JS/CSS/HTML files. Crucially, you must add a catch-all route in Express after your API routes. For example, you might do: app.get("*", (req, res) => { res.sendFile(path.resolve(\_*dirname, "build/index.html")); });. This way, any request that doesn’t match an API endpoint or a static asset will return the index.html file ￼. This allows React Router to handle the routing on the client side. Ensure your Express server differentiates API routes (e.g. those under /api) so that the catch-all does not override legitimate API requests. Using Express to serve the frontend means you only have one web-serving component (Express handles both APIs and static files), but you lose the benefit of the CDN edge caching that the static site component would have provided.
• Serving Static Files from Rust (Axum): Axum can also serve your React app’s static files. You can use Axum’s static file serving (for example, using tower_http::services::ServeDir or similar) to serve the index.html and static assets. As with Express, you need a catch-all fallback. In Axum, you might set up a fallback service on the router that serves index.html for any routes that weren’t matched by an API route or an actual file. One approach is to mount a ServeDir for your build folder and then handle errors by serving the index file when a file isn’t found. For instance, a common pattern is app.fallback(service_fn(|*| async { serve index.html ... })); after mounting API routes. If this isn’t configured, you’d encounter 404 errors when refreshing on a client-side route ￼ – essentially Axum would report “Not Found” because it doesn’t see a matching server route or file for a path like /home/customers. The solution is to have Axum return the React app’s index.html for any unknown path (while still allowing real static asset requests to go through to actual files). You can accomplish this either by using Axum’s router fallback or by explicitly matching all routes ("/*path") to a handler that serves the index file. This approach lets your Rust server handle everything (APIs + frontend), possibly reducing the number of moving parts. However, you’ll need to ensure correct configuration of MIME types and caching for static files, and implement the SPA fallback logic, which is a bit of extra coding compared to the turnkey static site hosting.

In all cases, after deploying, test that navigating directly to a sub-page (e.g. via refresh or URL input) works. If using the static site component, double-check the Custom Pages -> Catchall setting is pointing to the right file. If using Express or Axum to serve static content, make sure the catch-all route does not interfere with API routes (usually by mounting it last) and that it serves the correct file. When configured properly, the React Router v7 app will handle client-side routes seamlessly, and users won’t see 404 errors for valid front-end paths. Also consider enabling gzip or brotli compression for your static assets (Express can use compression middleware; for Axum, serve pre-compressed files or use a middleware) to improve performance.

Domain Structure: Subdomain vs Single Domain for APIs

You have a choice between exposing your backends under the same domain as the frontend (using path-based routing) or using a separate subdomain for the API. Each approach has implications for routing, CORS, and complexity:
• Single Domain (Path-Based Routing): Keeping everything under openagents.com (for example) means your React app and APIs share a domain. This is simpler for the frontend – you can make API calls to relative paths (no cross-origin issues) and share cookies or auth tokens easily. DigitalOcean App Platform makes this possible by allowing path prefixes to route to different components within one app ￼. For instance, the frontend could be served at / and API requests under /api could be directed to your Express/Rust backends. Bobby Iliev (DO Developer Advocate) suggests mapping app.com to the frontend and app.com/api to the backend service in a single App Platform app ￼. With this setup, you don’t need to configure CORS for the frontend to talk to the backend, since it’s the same origin. It also keeps your URL structure clean (everything under one domain). Ensure that the path you choose (e.g. /api, or even more specific like /api/v1 vs /api/v2 for each service) is configured in the App Platform settings or spec to route to the correct component. This approach is recommended if you want simplicity and a unified domain.
• Subdomain for API: Using a subdomain like api.openagents.com for your backend services means the frontend (at openagents.com) will be calling a different origin. DigitalOcean App Platform does not support mapping a single component of an app to a completely separate domain out-of-the-box (other than using path prefixes). If you require a subdomain, the typical solution is to create a separate App for the API service ￼. In this scenario, you might have one App Platform app hosting the React frontend (and perhaps one of the backends) on the main domain, and another App Platform app hosting the Rust/Express API on api.openagents.com. The two apps would be deployed separately. While this cleanly separates concerns, it introduces cross-origin requests. You will need to configure CORS so that the frontend domain is allowed to contact the API domain ￼. For example, set the Access-Control-Allow-Origin header to https://openagents.com on the API responses so that the browser permits the React app to consume them ￼. DigitalOcean App Platform allows configuring CORS policies per service in the settings, where you can specify allowed origins, methods, and headers without modifying code if you prefer. With a subdomain, if you use cookies for auth, you might need to set them with appropriate domain attributes or use tokens instead, as cookies by default won’t be shared across root and subdomain unless configured.

Pros/Cons: A subdomain approach gives a clear separation; you could even host the API in a different region or scaling plan. It also aligns with a common pattern of having an api. subdomain. However, the added complexity of CORS and needing separate deployments (with potentially separate environment config) is a consideration. On the other hand, a single domain with path routing simplifies local development and deployment (one app handles everything) and avoids CORS entirely. The App Platform team themselves often recommend using path-based routing for multiple components unless a separate domain is absolutely needed ￼ ￼. If you do need distinct domains (for example, if you had two entirely separate audiences or DNS setups for the services), be prepared to manage two apps and ensure both are properly secured (each will get its own SSL certificate via DO). In summary, if there’s no strong requirement for a subdomain, using a single domain with an /api path is usually the simplest and most straightforward route on DigitalOcean App Platform.

Docker Configuration on DigitalOcean App Platform

Both the Express and Rust/Axum services will need to run in containerized environments on App Platform. You should configure Docker for each in a way that is efficient and follows best practices for production.

Rust (Axum) Service: Since DigitalOcean doesn’t natively build Rust code (unlike Node which has buildpacks), you’ll use a Dockerfile for the Axum backend. A common best practice is to use a multi-stage Docker build for Rust. In the first stage, use the official Rust image to compile your application, and in the second stage use a lightweight base to run the compiled binary. For example, your Dockerfile might start with FROM rust:1.xx-slim-bullseye AS builder to build the project, then FROM debian:bullseye-slim AS runtime for the minimal runtime environment ￼ ￼. The build stage would compile your Axum app with --release, and then you’d copy the resulting binary (and any required assets) into the runtime stage. Finally, set the entrypoint to that binary. By copying only the compiled binary and necessary files, you exclude the entire Rust toolchain and build files from the final image, greatly reducing its size. In the example from a sample Axum app, after building, they copy the release binary into a slim Debian image and use that as the container’s entrypoint ￼. This yields a smaller image that is faster to deploy and has a smaller attack surface.

Consider using an Alpine base or other slim base for the runtime if possible, but be mindful of compatibility (Rust binaries compiled on glibc-based Debian won’t run on Alpine’s musl without special handling, so sticking to Debian slim is fine). The key is that the final image should contain only what is needed to run the app (the binary and perhaps an assets folder for static files, if Axum is serving the React build). Everything else (build tools, temp files) stays behind in the builder stage. This multi-stage approach is a Docker best practice for production images ￼, as it produces lean images which lead to faster startup and less resource usage.

Express Service: For Node/Express, you have two choices: use App Platform’s built-in Node environment (buildpacks) or supply a custom Dockerfile. If your Express app is straightforward (install from package.json and start with npm start), App Platform can detect it and build it without a Dockerfile. However, since you might be coordinating with a Rust service (and possibly building a front-end), a Dockerfile can give you more control. If you create a Dockerfile for Node, similarly aim for a slim final image. You could use a Node official image (e.g., node:18-alpine for runtime) and if you need to compile TypeScript or build something, do that in a builder stage (for example, use a heavier image to npm ci && npm run build then copy the results into a smaller runtime image). For serving a React app, you might not need a separate build stage if you use the same container to build and serve, but separating can help keep dev dependencies out of production. At minimum, use a Node image with only needed dependencies (the slim or alpine variants) in production.

DigitalOcean App Platform specifics: The platform will build your Docker images from your Dockerfiles unless you provide pre-built images. Building a Rust project can be time-consuming, so be aware that App Platform will take a bit of time to compile it on each deploy. Mark Knapik from the DO community notes that deploying via a Dockerfile yields slower build times on App Platform’s servers, but it is a flexible approach especially suited for complex setups or monorepos ￼. To improve build speed, you could build the Docker image yourself and push it to a registry (like Docker Hub or DigitalOcean Container Registry) and have App Platform pull that image directly, skipping the on-platform build. This requires more setup (CI or manual build steps), but can significantly speed up deployments if Rust compile times or large npm install times are an issue. Another approach Mark mentioned is using DO’s sample app repos or buildpacks for simplicity when possible ￼ ￼, but given our multi-language stack, Dockerfiles give the most control.

Make sure your Dockerfiles specify the correct listening port. By default, App Platform will route HTTP traffic to port 80 in the container. If your app listens on another port (say Express uses 3000), you either expose and instruct the platform which port, or simply have your app listen on 0.0.0.0:8080 or 0.0.0.0:80 as per DO conventions. In the App Spec, you can set the http_port if needed (e.g., 8080 as in some DO samples ￼). Many official sample Dockerfiles and buildpacks default to reading a $PORT environment variable that DO provides. For simplicity, you can do const PORT = process.env.PORT || 3000 in Node and 0.0.0.0:$PORT in Rust if using frameworks that support it, so the container listens on whichever port DO instructs.

To sum up, use multi-stage builds, slim base images, and appropriate Dockerignore files to keep images small and secure. Verify that each service’s container starts up correctly by testing locally (e.g., docker build . && docker run -p 8080:8080 ...) to catch any issues with static file paths or port binding. By optimizing your Dockerfiles, you ensure efficient builds and deployments on App Platform, which leads to better performance and quicker scaling of your app.

Managing API Routing Between Rust and Express

When you have two separate backends providing APIs, it’s important to design a clear strategy for routing and organizing those API endpoints. The goal is to ensure that each request is handled by the correct service with minimal overhead and that the division is transparent to the frontend.

Distinct API Paths: The simplest approach is to namespace the API routes for each backend. For example, you could let all Express-powered endpoints be under /api/users/_ or /api/v1/_ and Rust-powered endpoints under /api/data/_ or /api/v2/_, depending on your domain logic. This versioning scheme (v1 vs v2) is a common way to differentiate two sets of APIs ￼, especially if the Rust service is a newer iteration of an API. Internally, you would configure App Platform ingress rules so that requests with /api/v1 go to the Express component and /api/v2 go to the Rust component ￼. If you prefer functional separation instead of version numbers, that’s fine too—e.g., /api/auth/** routes to Express (maybe handling authentication or user management) and /api/reporting/** routes to Rust (handling data-heavy operations). The key is that there is no ambiguity about which service should handle a given URL path.

Make sure these prefixes do not overlap and are documented. In your React app, you might create an API utility that knows which base path to call for each kind of request. For instance, calls to the old API might go to /api/v1/login, whereas new endpoints go to /api/v2/analyze. From the React perspective, it’s just calling different endpoints; App Platform will ensure each request reaches the right backend.

Internal Communication: In some cases, one backend might need to talk to the other. Perhaps the Express server might offload a heavy computation to the Rust service, or the Rust service might need to validate something via Express. Rather than making such calls go out over the public internet, you can take advantage of DigitalOcean’s internal networking for App Platform. Components within the same app can reach each other by their service name over a private network ￼. For example, if your Rust service is named rust-api in the spec, the Express service can issue HTTP requests to http://rust-api (default port 80) internally ￼. This traffic does not leave the datacenter and doesn’t require hitting the public endpoint (no DNS lookup for external domain, no SSL overhead). This is useful for composing services or aggregating data between them. If you plan to do this, ensure that any such internal API calls are not exposed externally or interfering with the external API routes. You might keep some endpoints internal-only (not documented to users or behind an auth check).

However, if your two backends serve completely separate purposes, you might avoid internal calls altogether and let the frontend orchestrate which API to call. Keeping them loosely coupled (the frontend decides which API to contact) can simplify each service. But if there’s shared functionality (for example, Express handles auth for both, or Rust provides a service used by Express), design a clear interface for that. You could even designate one service as the API gateway that proxies to the other – though in this case, you’d be back to a single entry point. Given App Platform’s ability to route paths directly, a proxy is usually unnecessary overhead; the platform itself is effectively routing for you.

Consistent Practices: Try to maintain consistency between the APIs so that the user experience is uniform. For example, handle errors in a similar format (Express might return JSON errors, and Rust should do the same format), and use similar authorization methods. This way, the React frontend doesn’t have to implement two completely different ways of handling responses. If using JWT or sessions, consider how both backends validate those. Perhaps use a shared secret or token service so that a user logged in via Express endpoints can also be recognized by Rust endpoints (this might involve sharing JWT signing keys or session store, which is a design choice to make).

Also, manage environment configuration so that the React app knows the correct base URL for each API if they differ. If everything is under one domain and just different paths, the front-end can call relative paths (e.g. /api/v2/endpoint). If you ended up using a subdomain for one service, then calls to that service should include the full https://api.openagents.com/... origin, and you’ll handle CORS as discussed. In code, abstract this so it’s easy to switch if needed.

Finally, document the API routes for yourself and team members. Over time, you might migrate more functionality from Express to Rust (if that’s a goal for performance reasons). Having a versioned path (like /api/v1 for Node and /api/v2 for Rust) makes it straightforward to deprecate the old and encourage use of the new. DigitalOcean’s suggestion to use separate path prefixes for different components is exactly to support such microservice patterns ￼.

In summary, partition your API routes clearly by prefix or version, use App Platform’s routing rules to send each prefix to the appropriate backend, and leverage the internal network if the backends need to talk to each other behind the scenes. This will result in clean separation of concerns and efficient handling of requests by the service best suited for each task.

Performance and Security Best Practices

When running a full-stack application with multiple services, it’s important to keep an eye on both performance and security. Here are some best practices to consider:

Performance Tips
• Optimize Docker Images: Smaller images deploy faster and use fewer resources. Use multi-stage builds to exclude build tools and unnecessary files from production images ￼. For example, compile your code in one stage and then run it in a minimal environment (as we did with Rust and could do with Node). Also use lightweight base images (Debian slim or Alpine) where possible to reduce image size and attack surface ￼. This helps not just with disk/memory usage but also with transfer times during deployment.
• Leverage CDN for Static Assets: If you deploy the React app as a static site on App Platform, it will be served through DigitalOcean’s global CDN (which uses Cloudflare) ￼. This means faster load times for users around the world and less load on your backend. Even if you serve static files via Express or Axum, consider enabling caching (set far-future Cache-Control headers on static files) or offloading to a CDN if possible. The static site component route is the easiest path to get CDN benefits out-of-the-box.
• Scale Resources Appropriately: Monitor your services (App Platform provides metrics for CPU, memory). If the Express service is CPU-bound (remember Node.js is single-threaded per instance), you might scale it by increasing instance size or horizontally by adding more instances. Similarly, the Rust service might handle concurrency better per instance, but if it’s doing heavy computation, ensure it has enough CPU. Because App Platform load-balances requests, adding instances will distribute traffic ￼. Just ensure your app is stateless (which it should be for load balancing) so any instance can handle any request.
• Avoid Unnecessary API Hops: Try not to chain calls between Express and Rust if you don’t need to. For example, if the frontend can call Rust directly for a certain feature, let it do so instead of going through Express and then Express calling Rust. Each extra network hop adds latency. Use the direct path routing (or direct front-end calls) to hit the right service. Internal calls should also be optimized; if Express does need results from Rust, maybe batch requests or cache results to reduce repetitive load.
• Use Background Jobs for Heavy Tasks: If some API calls trigger very expensive operations (say data crunching in Rust or PDF generation in Node), consider using a job queue or at least running those tasks asynchronously so that you can respond quickly and maybe poll for results. App Platform supports “worker” components that don’t serve HTTP but can run tasks. Offloading long tasks there can free your web instances to serve other requests promptly. This is more of an architectural choice, but it can improve perceived performance for end-users.
• Configure Timeouts and Keep-Alive wisely: Ensure that any internal calls between services have reasonable timeouts to avoid hanging. On the client side, use keep-alive connections (browsers do this by default) to the same origin – not much you need to do, but just be aware if using HTTP clients in Node/Rust to call each other, reuse connections to reduce overhead.
• Profiling and Monitoring: During load, profile your Express route handlers and Rust endpoints. Rust will likely be very fast, but Node might become a bottleneck under CPU-intensive loads. If you find Node blocking, consider moving more logic to Rust or using Node worker threads/child processes for CPU work. Use DO’s built-in logs and perhaps integrate an APM tool for deeper insight if needed.

Security Practices
• Enable HTTPS and CORS correctly: DigitalOcean will provide HTTPS for both your main domain and any subdomains you add. Always use HTTPS in production. If you went with a subdomain for the API, configure CORS to only allow your frontend’s origin ￼. This ensures that other domains cannot randomly call your API (which helps prevent misuse). On App Platform, you can set CORS rules in the app spec or settings to allow only specific origins or patterns ￼. Since we likely allow the main site to call the API, list that explicitly. If everything is under one domain, CORS is not an issue, but you might still consider setting up a Content Security Policy on the frontend and appropriate headers.
• Use Environment Variables for Secrets: Never hard-code secrets (API keys, database URLs, etc.) in your code or Dockerfile. App Platform lets you store environment variables and secrets via the dashboard. Use these for things like database credentials, JWT secret keys, third-party API keys, etc. That way, even if someone saw your source, they wouldn’t see the secrets. Both your Express app and Rust app can be given environment vars securely. Also, scope them per component if needed (DO allows setting env vars at the component level or at the app level to be shared). For example, a database URL could be shared, whereas a Node-specific secret only goes to the Node component.
• Harden the Express App: Express should be put in production mode (NODE_ENV=production). Use security middlewares like helmet to set HTTP headers (to prevent XSS, clickjacking, etc.), and enable body-parser limits to avoid DOS via huge payloads. If you have any user input, use validation libraries to sanitize and validate inputs on both Express and Rust sides. Rust’s type system helps, but you should still handle invalid data (Axum + Serde for JSON will give a 400 for malformed JSON by default, which is good).
• Authentication and Authorization: If your app has login/auth, decide how to share auth between services. One approach is to use JSON Web Tokens (JWT) that the frontend passes on each request, so both Express and Rust can validate the token (just ensure they share the signing secret or public key). If using session cookies (perhaps managed by Express), Rust would need to either share a session store or you treat Express as an auth gateway. In a microservice setup, stateless tokens are easier. Implement robust auth checks on each API route (don’t assume because one service was called by another internally that the user is authorized, unless it’s an internal-only endpoint). Always validate on the service that ultimately processes the request.
• Least Privilege for Services: Run your services with minimal privileges. In Docker, you can use a non-root user in the runtime container. For example, after copying the binary in the Rust Dockerfile, switch to a non-root user to run it. Similarly, use Node’s Docker image that doesn’t run as root (some official Node images allow specifying a user). App Platform might do some of this for you, but it’s good to double-check. Also, lock down what each container can access – by default, containers in App Platform can only see each other (and only via HTTP calls) and the internet, which is fine. There’s no need for them to have open ports other than the service port.
• Regular Updates: Keep your dependencies up to date. Security vulnerabilities in NPM packages or Rust crates are discovered regularly. Periodically review npm audit reports and cargo audit (there’s a tool for Rust) to see if you need to upgrade a library. Rebuild and deploy to App Platform when important security fixes are released. App Platform makes redeployment easy, so take advantage of that to stay secure.
• Logging and Alerts: Implement proper logging on both backends for security-related events (e.g., login failures, unexpected errors). DigitalOcean App Platform aggregates logs and you can view them in the dashboard. Consider setting up alerts – the App Platform spec allows defining alert rules, for example if CPU usage is very high or if the app restarts frequently ￼ ￼. These can help catch issues like a denial-of-service attack or a runaway process. Also ensure your Node process has uncaught exception handlers (to avoid crashing on an error) and your Rust service handles panics (Axum will catch panics by default and not crash the whole process, but be mindful if using unwrap unsafely).
• Test for Common Vulnerabilities: Since you have two different tech stacks, be aware of different vulnerability domains. For Express/Node: watch out for prototype pollution, regex DOS, etc., by using updated packages. For Rust: memory safety is largely guaranteed, but logic bugs can still cause security issues. If your Rust service interacts with system commands or unsafe code, be extra careful. Use tools like cargo audit and maybe even fuzz testing for critical parsing logic. Also, ensure that error messages from both services don’t leak sensitive information (e.g., stack traces or implementation details) – set them to output generic messages in production.

By following these performance and security practices, you’ll set a strong foundation for your application. You’ll benefit from the scalability of a multi-service architecture on App Platform while keeping response times low and your data safe. As always, continue to review DigitalOcean’s documentation and community forums for any updates or specific tuning tips (for example, new features in App Platform or best practices others have discovered). Good luck with your deployment, and enjoy the combined power of React, Express, and Rust on the cloud!
