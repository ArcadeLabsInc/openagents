{"repo_map":"\nsrc/agents/agent.rs:\nâ‹®...\nâ”‚pub struct Agent {\nâ”‚    // Unique identifier for the agent\nâ”‚    pub id: Uuid,\nâ”‚    // Display name of the agent\nâ”‚    pub name: String,\nâ”‚    // Detailed description of the agent's purpose and capabilities\nâ”‚    pub description: String,\nâ”‚    // Nostr public key for agent identification and messaging\nâ”‚    pub pubkey: String,\nâ”‚    // Whether this agent definition is enabled for creating new instances\nâ‹®...\nâ”‚pub struct AgentInstance {\nâ”‚    // Unique identifier for this instance\nâ”‚    pub id: Uuid,\nâ”‚    // Reference to the parent agent\nâ”‚    pub agent_id: Uuid,\nâ”‚    // Current operational status of this instance\nâ”‚    pub status: InstanceStatus,\nâ”‚    // Unix timestamp when this instance started running\nâ”‚    pub created_at: i64,\nâ”‚    // Unix timestamp when this instance stopped running (None if still running)\nâ‹®...\nâ”‚pub struct Plan {\nâ”‚    // Unique identifier for the plan\nâ”‚    pub id: Uuid,\nâ”‚    // Reference to the agent that created this plan\nâ”‚    pub agent_id: Uuid,\nâ”‚    // Human readable name of the plan\nâ”‚    pub name: String,\nâ”‚    // Detailed description of what this plan aims to accomplish\nâ”‚    pub description: String,\nâ”‚    // Current status of the plan\nâ‹®...\nâ”‚pub struct Task {\nâ”‚    // Unique identifier for the task\nâ”‚    pub id: Uuid,\nâ”‚    // Reference to the plan this task belongs to\nâ”‚    pub plan_id: Uuid,\nâ”‚    // Reference to the agent instance executing this task\nâ”‚    pub instance_id: Uuid,\nâ”‚    // Type of task (e.g., \"analyze_data\", \"send_email\", etc)\nâ”‚    pub task_type: String,\nâ”‚    // Current status of the task\nâ‹®...\nâ”‚pub enum InstanceStatus {\nâ”‚    Starting,\nâ”‚    Running,\nâ”‚    Paused,\nâ”‚    Stopping,\nâ”‚    Stopped,\nâ”‚    Error,\nâ‹®...\nâ”‚pub enum PlanStatus {\nâ”‚    Created,\nâ”‚    InProgress,\nâ”‚    Completed,\nâ”‚    Failed,\nâ”‚    Cancelled,\nâ‹®...\nâ”‚pub enum TaskStatus {\nâ”‚    Pending,\nâ”‚    Scheduled,\nâ”‚    Running,\nâ”‚    Completed,\nâ”‚    Failed,\nâ”‚    Cancelled,\nâ‹®...\n\nsrc/agents/manager.rs:\nâ‹®...\nâ”‚pub struct AgentManager {\nâ”‚    pool: PgPool,\nâ”‚    instances: Arc<RwLock<HashMap<Uuid, AgentInstance>>>,\nâ”‚    instance_states: Arc<RwLock<HashMap<Uuid, serde_json::Value>>>,\nâ”‚    instance_metrics: Arc<RwLock<HashMap<Uuid, serde_json::Value>>>,\nâ‹®...\nâ”‚impl AgentManager {\nâ”‚    pub fn new(pool: PgPool) -> Self {\nâ”‚        Self {\nâ”‚            pool,\nâ”‚            instances: Arc::new(RwLock::new(HashMap::new())),\nâ”‚            instance_states: Arc::new(RwLock::new(HashMap::new())),\nâ”‚            instance_metrics: Arc::new(RwLock::new(HashMap::new())),\nâ”‚        }\nâ”‚    }\nâ”‚\nâ”‚    // Agent Management\nâ”‚    pub async fn create_agent(\nâ”‚        &self,\nâ”‚        name: &str,\nâ”‚        description: &str,\nâ”‚        pubkey: &str,\nâ”‚        config: serde_json::Value,\nâ‹®...\nâ”‚    pub async fn get_agent(&self, id: Uuid) -> Result<Agent> {\nâ”‚        let record = sqlx::query!(\nâ”‚            r#\"\nâ”‚            SELECT id, name, description, pubkey, enabled, config, \nâ”‚                   EXTRACT(EPOCH FROM created_at)::BIGINT as created_at\nâ”‚            FROM agents WHERE id = $1\nâ”‚            \"#,\nâ”‚            id\nâ”‚        )\nâ”‚        .fetch_one(&self.pool)\nâ‹®...\nâ”‚    pub async fn create_instance(&self, agent_id: Uuid) -> Result<AgentInstance> {\nâ”‚        // Get agent and validate\nâ”‚        let agent = self.get_agent(agent_id).await?;\nâ”‚        if !agent.enabled {\nâ”‚            return Err(anyhow!(\"Agent is disabled\"));\nâ”‚        }\nâ”‚\nâ”‚        // Check instance limits\nâ”‚        let instance_count = sqlx::query!(\nâ”‚            \"SELECT COUNT(*) as count FROM agent_instances WHERE agent_id = $1 AND status != 'Stopp\nâ‹®...\nâ”‚    pub async fn set_instance_state(\nâ”‚        &self,\nâ”‚        instance_id: Uuid,\nâ”‚        state: serde_json::Value,\nâ‹®...\nâ”‚    pub async fn get_instance_state(&self, instance_id: Uuid) -> Result<Option<serde_json::Value>> \nâ”‚        let records = sqlx::query!(\nâ”‚            r#\"\nâ”‚            SELECT state_key, state_value\nâ”‚            FROM agent_states\nâ”‚            WHERE instance_id = $1\nâ”‚            \"#,\nâ”‚            instance_id\nâ”‚        )\nâ”‚        .fetch_all(&self.pool)\nâ‹®...\nâ”‚    pub async fn update_instance_metrics(\nâ”‚        &self,\nâ”‚        instance_id: Uuid,\nâ”‚        metrics: serde_json::Value,\nâ‹®...\nâ”‚    fn validate_agent_config(&self, config: serde_json::Value) -> Result<serde_json::Value> {\nâ”‚        let mut config = config\nâ”‚            .as_object()\nâ”‚            .ok_or(anyhow!(\"Invalid config format\"))?\nâ”‚            .clone();\nâ”‚\nâ”‚        // Ensure required fields with defaults\nâ”‚        if !config.contains_key(\"version\") {\nâ”‚            config.insert(\"version\".into(), json!(\"1.0.0\"));\nâ”‚        }\nâ‹®...\n\nsrc/agents/mod.rs:\nâ‹®...\nâ”‚pub mod manager;\nâ”‚\nâ‹®...\n\nsrc/configuration.rs:\nâ‹®...\nâ”‚pub struct DatabaseSettings {\nâ”‚    #[serde(default)]\nâ”‚    pub username: String,\nâ”‚    #[serde(default = \"default_password\")]\nâ”‚    pub password: Secret<String>,\nâ”‚    #[serde(default = \"default_port\")]\nâ”‚    pub port: u16,\nâ”‚    #[serde(default)]\nâ”‚    pub host: String,\nâ”‚    #[serde(default)]\nâ‹®...\nâ”‚impl DatabaseSettings {\nâ”‚    pub fn connect_options(&self) -> PgConnectOptions {\nâ”‚        // First check for DATABASE_URL\nâ”‚        if let Ok(database_url) = std::env::var(\"DATABASE_URL\") {\nâ”‚            info!(\"Using DATABASE_URL from environment\");\nâ”‚\nâ”‚            let url = match Url::parse(&database_url) {\nâ”‚                Ok(url) => {\nâ”‚                    debug!(\"Successfully parsed DATABASE_URL\");\nâ”‚                    url\nâ”‚                }\nâ‹®...\nâ”‚pub fn get_configuration() -> Result<Settings, ConfigError> {\nâ”‚    info!(\"Loading configuration...\");\nâ”‚\nâ”‚    let base_path = std::env::current_dir()\nâ”‚        .expect(\"Failed to determine current directory\")\nâ”‚        .join(\"configuration\");\nâ”‚\nâ”‚    let environment: AppEnvironment = std::env::var(\"APP_ENVIRONMENT\")\nâ”‚        .unwrap_or_else(|_| {\nâ”‚            info!(\"APP_ENVIRONMENT not set, defaulting to 'local'\");\nâ‹®...\nâ”‚pub enum AppEnvironment {\nâ”‚    Local,\nâ”‚    Production,\nâ‹®...\nâ”‚impl AppEnvironment {\nâ”‚    pub fn as_str(&self) -> &'static str {\nâ”‚        match self {\nâ”‚            AppEnvironment::Local => \"local\",\nâ”‚            AppEnvironment::Production => \"production\",\nâ”‚        }\nâ”‚    }\nâ‹®...\n\nsrc/database.rs:\nâ‹®...\nâ”‚pub async fn get_connection_pool(configuration: &Settings) -> Result<PgPool, sqlx::Error> {\nâ”‚    info!(\"Creating database connection pool...\");\nâ”‚\nâ”‚    let connect_options = configuration.database.connect_options();\nâ”‚\nâ”‚    debug!(\"Attempting to connect to database...\");\nâ”‚\nâ”‚    PgPoolOptions::new()\nâ”‚        .max_connections(5)\nâ”‚        .connect_with(connect_options)\nâ‹®...\n\nsrc/lib.rs:\nâ‹®...\nâ”‚pub mod database;\nâ”‚pub mod emailoptin;\nâ”‚pub mod nostr;\nâ‹®...\nâ”‚pub async fn run() -> std::io::Result<()> {\nâ”‚    if std::env::var(\"RUST_LOG\").is_err() {\nâ”‚        std::env::set_var(\"RUST_LOG\", \"info\");\nâ”‚    }\nâ”‚    env_logger::init();\nâ”‚    dotenvy::dotenv().ok();\nâ”‚\nâ”‚    info!(\"ðŸš€ Starting OpenAgents...\");\nâ”‚\nâ”‚    // Load configuration\nâ‹®...\n\nsrc/nostr/db.rs:\nâ‹®...\nâ”‚pub struct Database {\nâ”‚    pool: Pool<Postgres>,\nâ‹®...\n\nsrc/nostr/event.rs:\nâ‹®...\nâ”‚pub struct Event {\nâ”‚    pub id: String,\nâ”‚    pub pubkey: String,\nâ”‚    pub created_at: i64,\nâ”‚    pub kind: i32,\nâ”‚    pub tags: Vec<Vec<String>>,\nâ”‚    pub content: String,\nâ”‚    pub sig: String,\nâ”‚    #[serde(skip)]\nâ”‚    pub tagidx: Option<HashMap<char, HashSet<String>>>,\nâ‹®...\nâ”‚impl Event {\nâ”‚    pub fn validate(&self) -> Result<(), &'static str> {\nâ”‚        // Validate event format and signature\nâ”‚        let canonical = self.to_canonical().ok_or(\"Could not canonicalize event\")?;\nâ”‚\nâ”‚        // Compute SHA256 of canonical form\nâ”‚        let digest: sha256::Hash = sha256::Hash::hash(canonical.as_bytes());\nâ”‚        let hex_digest = format!(\"{digest:x}\");\nâ”‚\nâ”‚        // Verify ID matches computed hash\nâ”‚        if self.id != hex_digest {\nâ‹®...\nâ”‚    pub fn to_canonical(&self) -> Option<String> {\nâ”‚        let elements = vec![\nâ”‚            serde_json::Value::Number(0.into()), // id placeholder\nâ”‚            serde_json::Value::String(self.pubkey.clone()),\nâ”‚            serde_json::Value::Number(self.created_at.into()),\nâ”‚            serde_json::Value::Number(self.kind.into()),\nâ”‚            self.tags_to_canonical(),\nâ”‚            serde_json::Value::String(self.content.clone()),\nâ”‚        ];\nâ”‚\nâ‹®...\nâ”‚    pub fn build_index(&mut self) {\nâ”‚        if self.tags.is_empty() {\nâ”‚            return;\nâ”‚        }\nâ”‚\nâ”‚        let mut idx: HashMap<char, HashSet<String>> = HashMap::new();\nâ”‚\nâ”‚        for tag in self.tags.iter().filter(|t| t.len() > 1) {\nâ”‚            if let Some(tag_char) = tag.first().and_then(|s| s.chars().next()) {\nâ”‚                if let Some(tag_val) = tag.get(1) {\nâ‹®...\nâ”‚    pub fn generic_tag_val_intersect(&self, tagname: char, check: &HashSet<String>) -> bool {\nâ”‚        match &self.tagidx {\nâ”‚            Some(idx) => match idx.get(&tagname) {\nâ”‚                Some(valset) => !valset.is_disjoint(check),\nâ”‚                None => false,\nâ”‚            },\nâ”‚            None => false,\nâ”‚        }\nâ‹®...\n\nsrc/nostr/mod.rs:\nâ”‚pub mod db;\nâ”‚pub mod event;\nâ”‚pub mod relay;\nâ”‚pub mod subscription;\n\nsrc/nostr/subscription.rs:\nâ‹®...\nâ”‚pub struct Subscription {\nâ”‚    pub id: String,\nâ”‚    pub filters: Vec<ReqFilter>,\nâ‹®...\nâ”‚pub struct ReqFilter {\nâ”‚    pub ids: Option<Vec<String>>,\nâ”‚    pub authors: Option<Vec<String>>,\nâ”‚    pub kinds: Option<Vec<i32>>,\nâ”‚    pub since: Option<i64>,\nâ”‚    pub until: Option<i64>,\nâ”‚    pub limit: Option<u64>,\nâ”‚    #[serde(flatten)]\nâ”‚    pub tags: HashMap<String, Vec<String>>,\nâ‹®...\nâ”‚impl ReqFilter {\nâ”‚    pub fn matches_event(&self, event: &Event) -> bool {\nâ”‚        // Check basic fields\nâ”‚        if let Some(ids) = &self.ids {\nâ”‚            if !ids.iter().any(|id| event.id.starts_with(id)) {\nâ”‚                return false;\nâ”‚            }\nâ”‚        }\nâ”‚\nâ”‚        if let Some(authors) = &self.authors {\nâ”‚            if !authors\nâ‹®...\n\nsrc/server/admin/middleware.rs:\nâ‹®...\nâ”‚pub struct AdminAuth;\nâ”‚\nâ‹®...\nâ”‚impl<S, B> Service<ServiceRequest> for AdminAuthMiddleware<S>\nâ‹®...\nâ”‚{\nâ‹®...\nâ”‚    fn call(&self, req: ServiceRequest) -> Self::Future {\nâ”‚        let config = match get_configuration() {\nâ”‚            Ok(config) => config,\nâ”‚            Err(e) => {\nâ”‚                let (http_req, _) = req.into_parts();\nâ”‚                let response = HttpResponse::InternalServerError()\nâ”‚                    .json(serde_json::json!({\"error\": format!(\"Config error: {}\", e)}));\nâ”‚                return Box::pin(async move {\nâ”‚                    Ok(ServiceResponse::new(http_req, response).map_into_right_body())\nâ”‚                });\nâ‹®...\n\nsrc/server/admin/mod.rs:\nâ”‚pub mod middleware;\nâ”‚pub mod routes;\n\nsrc/server/mod.rs:\nâ”‚pub mod admin;\nâ”‚pub mod config;\nâ”‚pub mod routes;\n\ntests/agent.rs:\nâ‹®...\nâ”‚mod core;\nâ”‚#[path = \"agent/manager.rs\"]\nâ”‚mod manager;\nâ”‚#[path = \"agent/manager_comprehensive.rs\"]\nâ”‚mod manager_comprehensive;\nâ”‚#[path = \"agent/manager_impl.rs\"]\nâ”‚mod manager_impl;\nâ”‚#[path = \"agent/nostr.rs\"]\nâ”‚mod nostr;\nâ”‚\nâ‹®...\n\ntests/agent/manager.rs:\nâ‹®...\nâ”‚pub struct MockAgentManager {\nâ”‚    agents: Vec<Agent>,\nâ”‚    instances: Vec<AgentInstance>,\nâ”‚    plans: Vec<Plan>,\nâ”‚    tasks: Vec<Task>,\nâ”‚    instance_states: HashMap<Uuid, serde_json::Value>,\nâ”‚    instance_counts: HashMap<Uuid, usize>, // Track instance count per agent\nâ‹®...\nâ”‚impl MockAgentManager {\nâ”‚    pub fn new() -> Self {\nâ”‚        Self {\nâ”‚            agents: Vec::new(),\nâ”‚            instances: Vec::new(),\nâ”‚            plans: Vec::new(),\nâ”‚            tasks: Vec::new(),\nâ”‚            instance_states: HashMap::new(),\nâ”‚            instance_counts: HashMap::new(),\nâ”‚        }\nâ‹®...\nâ”‚    pub fn create_agent(\nâ”‚        &mut self,\nâ”‚        name: &str,\nâ”‚        description: &str,\nâ”‚        config: serde_json::Value,\nâ‹®...\nâ”‚    pub fn create_instance(&mut self, agent_id: Uuid) -> AgentInstance {\nâ”‚        // Check resource limits\nâ”‚        if let Some(agent) = self.agents.iter().find(|a| a.id == agent_id) {\nâ”‚            let current_count = self.instance_counts.get(&agent_id).unwrap_or(&0);\nâ”‚\nâ”‚            if let Some(max_instances) = agent.config.get(\"max_instances\").and_then(|v| v.as_u64())\nâ”‚            {\nâ”‚                if *current_count >= max_instances as usize {\nâ”‚                    return AgentInstance {\nâ”‚                        id: Uuid::new_v4(),\nâ‹®...\nâ”‚    pub fn create_plan(&mut self, agent_id: Uuid, name: &str) -> Plan {\nâ”‚        let plan = Plan {\nâ”‚            id: Uuid::new_v4(),\nâ”‚            agent_id,\nâ”‚            name: name.into(),\nâ”‚            description: \"Test plan\".into(),\nâ”‚            status: PlanStatus::Created,\nâ”‚            task_ids: Vec::new(),\nâ”‚            created_at: Utc::now().timestamp(),\nâ”‚            ended_at: None,\nâ‹®...\nâ”‚    pub fn create_task(&mut self, plan_id: Uuid, instance_id: Uuid, task_type: &str) -> Task {\nâ”‚        let task = Task {\nâ”‚            id: Uuid::new_v4(),\nâ”‚            plan_id,\nâ”‚            instance_id,\nâ”‚            task_type: task_type.into(),\nâ”‚            status: TaskStatus::Pending,\nâ”‚            priority: 1,\nâ”‚            input: json!({}),\nâ”‚            output: None,\nâ‹®...\nâ”‚    pub fn update_task_status(&mut self, task_id: Uuid, status: TaskStatus) -> bool {\nâ”‚        if let Some(task) = self.tasks.iter_mut().find(|t| t.id == task_id) {\nâ”‚            task.status = status.clone();\nâ”‚            if matches!(status, TaskStatus::Running) {\nâ”‚                task.started_at = Some(Utc::now().timestamp());\nâ”‚            }\nâ”‚            if matches!(status, TaskStatus::Completed | TaskStatus::Failed) {\nâ”‚                task.ended_at = Some(Utc::now().timestamp());\nâ”‚            }\nâ”‚\nâ‹®...\nâ”‚    pub fn set_instance_state(&mut self, instance_id: Uuid, state: serde_json::Value) -> bool {\nâ”‚        if self.instances.iter().any(|i| i.id == instance_id) {\nâ”‚            self.instance_states.insert(instance_id, state);\nâ”‚            true\nâ”‚        } else {\nâ”‚            false\nâ”‚        }\nâ‹®...\nâ”‚    pub fn get_instance_state(&self, instance_id: Uuid) -> Option<serde_json::Value> {\nâ”‚        self.instance_states.get(&instance_id).cloned()\nâ‹®...\n\ntests/agent/manager_comprehensive.rs:\nâ‹®...\nâ”‚async fn setup_test_db() -> PgPool {\nâ”‚    let database_url = env::var(\"DATABASE_URL\").expect(\"DATABASE_URL must be set\");\nâ”‚    PgPool::connect(&database_url).await.unwrap()\nâ‹®...\n\ntests/agent/manager_impl.rs:\nâ‹®...\nâ”‚async fn setup_test_db() -> PgPool {\nâ”‚    let database_url = env::var(\"DATABASE_URL\").expect(\"DATABASE_URL must be set\");\nâ”‚    PgPool::connect(&database_url).await.unwrap()\nâ‹®...\n\ntests/agent/mod.rs:\nâ”‚pub mod core;\nâ”‚pub mod manager;\nâ”‚pub mod manager_impl;\nâ”‚pub mod manager_comprehensive;\nâ”‚pub mod nostr;\n\ntests/agent/nostr.rs:\nâ‹®...\nâ”‚fn create_agent_status_event(agent: &Agent, instance: &AgentInstance) -> Event {\nâ”‚    Event {\nâ”‚        id: \"a6b6c6d6e6f6\".into(),\nâ”‚        pubkey: agent.pubkey.clone(),\nâ”‚        created_at: Utc::now().timestamp(),\nâ”‚        kind: 30001,\nâ”‚        tags: vec![\nâ”‚            vec![\"d\".into(), \"agent_status\".into()],\nâ”‚            vec![\"p\".into(), agent.pubkey.clone()],\nâ”‚        ],\nâ‹®...\nâ”‚fn create_agent_task_event(agent: &Agent, task_type: &str, progress: u8) -> Event {\nâ”‚    Event {\nâ”‚        id: \"b7c7d7e7f7g7\".into(),\nâ”‚        pubkey: agent.pubkey.clone(),\nâ”‚        created_at: Utc::now().timestamp(),\nâ”‚        kind: 1001,\nâ”‚        tags: vec![\nâ”‚            vec![\"p\".into(), agent.pubkey.clone()],\nâ”‚            vec![\"t\".into(), \"task_update\".into()],\nâ”‚            vec![\"r\".into(), task_type.into()],\nâ‹®...\n\ntests/nostr/mod.rs:\nâ”‚mod database;\nâ”‚mod event;\nâ”‚mod subscription;\n","metadata":{"repo_url":"https://github.com/OpenAgentsInc/openagents","config":{}}}%
