src/agents/agent.rs: ⋮... │pub struct Agent { │ // Unique identifier for the agent │ pub id: Uuid, │ // Display name of the agent │ pub name: String, │ // Detailed description of the agent's purpose and capabilities │ pub description: String, │ // Nostr public key for agent identification and messaging │ pub pubkey: String, │ // Whether this agent definition is enabled for creating new instances ⋮... │pub struct AgentInstance { │ // Unique identifier for this instance │ pub id: Uuid, │ // Reference to the parent agent │ pub agent*id: Uuid, │ // Current operational status of this instance │ pub status: InstanceStatus, │ // Unix timestamp when this instance started running │ pub created_at: i64, │ // Unix timestamp when this instance stopped running (None if still running) ⋮... │pub struct Plan { │ // Unique identifier for the plan │ pub id: Uuid, │ // Reference to the agent that created this plan │ pub agent_id: Uuid, │ // Human readable name of the plan │ pub name: String, │ // Detailed description of what this plan aims to accomplish │ pub description: String, │ // Current status of the plan ⋮... │pub struct Task { │ // Unique identifier for the task │ pub id: Uuid, │ // Reference to the plan this task belongs to │ pub plan_id: Uuid, │ // Reference to the agent instance executing this task │ pub instance_id: Uuid, │ // Type of task (e.g., "analyze_data", "send_email", etc) │ pub task_type: String, │ // Current status of the task ⋮... │pub enum InstanceStatus { │ Starting, │ Running, │ Paused, │ Stopping, │ Stopped, │ Error, ⋮... │pub enum PlanStatus { │ Created, │ InProgress, │ Completed, │ Failed, │ Cancelled, ⋮... │pub enum TaskStatus { │ Pending, │ Scheduled, │ Running, │ Completed, │ Failed, │ Cancelled, ⋮... src/agents/manager.rs: ⋮... │pub struct AgentManager { │ pool: PgPool, │ instances: Arc>>, │ instance_states: Arc>>, │ instance_metrics: Arc>>, ⋮... │impl AgentManager { │ pub fn new(pool: PgPool) -> Self { │ Self { │ pool, │ instances: Arc::new(RwLock::new(HashMap::new())), │ instance_states: Arc::new(RwLock::new(HashMap::new())), │ instance_metrics: Arc::new(RwLock::new(HashMap::new())), │ } │ } │ │ // Agent Management │ pub async fn create_agent( │ &self, │ name: &str, │ description: &str, │ pubkey: &str, │ config: serde_json::Value, ⋮... │ pub async fn get_agent(&self, id: Uuid) -> Result { │ let record = sqlx::query!( │ r#" │ SELECT id, name, description, pubkey, enabled, config, │ EXTRACT(EPOCH FROM created_at)::BIGINT as created_at │ FROM agents WHERE id = $1 │ "#, │ id │ ) │ .fetch_one(&self.pool) ⋮... │ pub async fn create_instance(&self, agent_id: Uuid) -> Result { │ // Get agent and validate │ let agent = self.get_agent(agent_id).await?; │ if !agent.enabled { │ return Err(anyhow!("Agent is disabled")); │ } │ │ // Check instance limits │ let instance_count = sqlx::query!( │ "SELECT COUNT(\*) as count FROM agent_instances WHERE agent_id = $1 AND status != 'Stopp ⋮... │ pub async fn set_instance_state( │ &self, │ instance_id: Uuid, │ state: serde_json::Value, ⋮... │ pub async fn get_instance_state(&self, instance_id: Uuid) -> Result> │ let records = sqlx::query!( │ r#" │ SELECT state_key, state_value │ FROM agent_states │ WHERE instance_id = $1 │ "#, │ instance_id │ ) │ .fetch_all(&self.pool) ⋮... │ pub async fn update_instance_metrics( │ &self, │ instance_id: Uuid, │ metrics: serde_json::Value, ⋮... │ fn validate_agent_config(&self, config: serde_json::Value) -> Result { │ let mut config = config │ .as_object() │ .ok_or(anyhow!("Invalid config format"))? │ .clone(); │ │ // Ensure required fields with defaults │ if !config.contains_key("version") { │ config.insert("version".into(), json!("1.0.0")); │ } ⋮... src/agents/mod.rs: ⋮... │pub mod manager; │ ⋮... src/configuration.rs: ⋮... │pub struct DatabaseSettings { │ #[serde(default)] │ pub username: String, │ #[serde(default = "default_password")] │ pub password: Secret, │ #[serde(default = "default_port")] │ pub port: u16, │ #[serde(default)] │ pub host: String, │ #[serde(default)] ⋮... │impl DatabaseSettings { │ pub fn connect_options(&self) -> PgConnectOptions { │ // First check for DATABASE_URL │ if let Ok(database_url) = std::env::var("DATABASE_URL") { │ info!("Using DATABASE_URL from environment"); │ │ let url = match Url::parse(&database_url) { │ Ok(url) => { │ debug!("Successfully parsed DATABASE_URL"); │ url │ } ⋮... │pub fn get_configuration() -> Result { │ info!("Loading configuration..."); │ │ let base_path = std::env::current_dir() │ .expect("Failed to determine current directory") │ .join("configuration"); │ │ let environment: AppEnvironment = std::env::var("APP_ENVIRONMENT") │ .unwrap_or_else(|*| { │ info!("APP_ENVIRONMENT not set, defaulting to 'local'"); ⋮... │pub enum AppEnvironment { │ Local, │ Production, ⋮... │impl AppEnvironment { │ pub fn as_str(&self) -> &'static str { │ match self { │ AppEnvironment::Local => "local", │ AppEnvironment::Production => "production", │ } │ } ⋮... │impl TryFrom for AppEnvironment { │ type Error = String; │ │ fn try_from(s: String) -> Result { │ match s.to_lowercase().as_str() { │ "local" => Ok(Self::Local), │ "production" => Ok(Self::Production), │ other => { │ error!("Invalid environment: {}", other); │ Err(format!( ⋮... src/database.rs: ⋮... │pub async fn get_connection_pool(configuration: &Settings) -> Result { │ info!("Creating database connection pool..."); │ │ let connect_options = configuration.database.connect_options(); │ │ debug!("Attempting to connect to database..."); │ │ PgPoolOptions::new() │ .max_connections(5) │ .connect_with(connect_options) ⋮... src/lib.rs: ⋮... │pub mod database; │pub mod emailoptin; │pub mod nostr; ⋮... │pub async fn repomap(headers: HeaderMap) -> Response { │ let is_htmx = headers.contains_key("hx-request"); │ let title = "Repository Map"; │ let path = "/repomap"; │ │ if is_htmx { │ let content = ContentTemplate { path }.render().unwrap(); │ let mut response = Response::new(content.into()); │ response.headers_mut().insert( │ "HX-Title", ⋮... │pub async fn generate_repomap( │ State(service): State>, │ Form(req): Form, ⋮... src/nostr/db.rs: ⋮... │pub struct Database { │ pool: Pool, ⋮... src/nostr/event.rs: ⋮... │pub struct Event { │ pub id: String, │ pub pubkey: String, │ pub created_at: i64, │ pub kind: i32, │ pub tags: Vec>, │ pub content: String, │ pub sig: String, │ #[serde(skip)] │ pub tagidx: Option>>, ⋮... │impl Event { │ pub fn validate(&self) -> Result<(), &'static str> { │ // Validate event format and signature │ let canonical = self.to_canonical().ok_or("Could not canonicalize event")?; │ │ // Compute SHA256 of canonical form │ let digest: sha256::Hash = sha256::Hash::hash(canonical.as_bytes()); │ let hex_digest = format!("{digest:x}"); │ │ // Verify ID matches computed hash │ if self.id != hex_digest { ⋮... │ pub fn to_canonical(&self) -> Option { │ let elements = vec![ │ serde_json::Value::Number(0.into()), // id placeholder │ serde_json::Value::String(self.pubkey.clone()), │ serde_json::Value::Number(self.created_at.into()), │ serde_json::Value::Number(self.kind.into()), │ self.tags_to_canonical(), │ serde_json::Value::String(self.content.clone()), │ ]; │ ⋮... │ pub fn build_index(&mut self) { │ if self.tags.is_empty() { │ return; │ } │ │ let mut idx: HashMap> = HashMap::new(); │ │ for tag in self.tags.iter().filter(|t| t.len() > 1) { │ if let Some(tag_char) = tag.first().and_then(|s| s.chars().next()) { │ if let Some(tag_val) = tag.get(1) { ⋮... │ pub fn generic_tag_val_intersect(&self, tagname: char, check: &HashSet) -> bool { │ match &self.tagidx { │ Some(idx) => match idx.get(&tagname) { │ Some(valset) => !valset.is_disjoint(check), │ None => false, │ }, │ None => false, │ } ⋮... src/nostr/mod.rs: │pub mod axum_relay; │pub mod db; │pub mod event; │pub mod subscription; src/nostr/subscription.rs: ⋮... │pub struct Subscription { │ pub id: String, │ pub filters: Vec, ⋮... │pub struct ReqFilter { │ pub ids: Option>, │ pub authors: Option>, │ pub kinds: Option>, │ pub since: Option, │ pub until: Option, │ pub limit: Option, │ #[serde(flatten)] │ pub tags: HashMap>, ⋮... │impl ReqFilter { │ pub fn matches_event(&self, event: &Event) -> bool { │ // Check basic fields │ if let Some(ids) = &self.ids { │ if !ids.iter().any(|id| event.id.starts_with(id)) { │ return false; │ } │ } │ │ if let Some(authors) = &self.authors { │ if !authors ⋮... src/server/admin/mod.rs: │pub mod middleware; │pub mod routes; src/server/mod.rs: │pub mod admin; │pub mod config; │pub mod services; src/server/services/repomap.rs: ⋮... │pub struct RepomapService { │ client: Client, │ api_key: String, │ base_url: String, ⋮... │impl RepomapService { │ pub fn new(api_key: String) -> Self { │ Self { │ client: Client::new(), │ api_key, │ base_url: "https://aider.openagents.com".to_string(), │ } │ } │ │ pub fn with_base_url(api_key: String, base_url: String) -> Self { ⋮... │ pub async fn generate_repomap(&self, repo_url: String) -> Result { │ info!("Making request to aider service for repo: {}", repo_url); │ │ let url = format!("{}/api/v1/repomap/generate", self.base_url); │ let response = self │ .client │ .post(&url) │ .header("Content-Type", "application/json") │ .header("X-API-Key", &self.api_key) │ .json(&serde_json::json!({ ⋮... tests/admin_routes.rs: ⋮... │async fn setup_test_db() -> sqlx::PgPool { │ // Use a dedicated test database │ let pool = sqlx::PgPool::connect("postgres://postgres:password@localhost:5432/openagents_test") │ .await │ .unwrap(); │ │ // Drop and recreate test table │ sqlx::query("DROP TABLE IF EXISTS events") │ .execute(&pool) │ .await ⋮... tests/agent.rs: ⋮... │mod core; │#[path = "agent/manager.rs"] │mod manager; │#[path = "agent/manager_comprehensive.rs"] │mod manager_comprehensive; │#[path = "agent/manager_impl.rs"] │mod manager_impl; │#[path = "agent/nostr.rs"] │mod nostr; │ ⋮... tests/agent/manager.rs: ⋮... │impl MockAgentManager { │ pub fn new() -> Self { │ Self { │ agents: Vec::new(), │ instances: Vec::new(), │ plans: Vec::new(), │ tasks: Vec::new(), │ instance_states: HashMap::new(), │ instance_counts: HashMap::new(), │ } ⋮... │ pub fn create_agent( │ &mut self, │ name: &str, │ description: &str, │ config: serde_json::Value, ⋮... │ pub fn create_instance(&mut self, agent_id: Uuid) -> AgentInstance { │ // Check resource limits │ if let Some(agent) = self.agents.iter().find(|a| a.id == agent_id) { │ let current_count = self.instance_counts.get(&agent_id).unwrap_or(&0); │ │ if let Some(max_instances) = agent.config.get("max_instances").and_then(|v| v.as_u64()) │ { │ if \*current_count >= max_instances as usize { │ return AgentInstance { │ id: Uuid::new_v4(), ⋮... │ pub fn create_plan(&mut self, agent_id: Uuid, name: &str) -> Plan { │ let plan = Plan { │ id: Uuid::new_v4(), │ agent_id, │ name: name.into(), │ description: "Test plan".into(), │ status: PlanStatus::Created, │ task_ids: Vec::new(), │ created_at: Utc::now().timestamp(), │ ended_at: None, ⋮... │ pub fn create_task(&mut self, plan_id: Uuid, instance_id: Uuid, task_type: &str) -> Task { │ let task = Task { │ id: Uuid::new_v4(), │ plan_id, │ instance_id, │ task_type: task_type.into(), │ status: TaskStatus::Pending, │ priority: 1, │ input: json!({}), │ output: None, ⋮... │ pub fn update_task_status(&mut self, task_id: Uuid, status: TaskStatus) -> bool { │ if let Some(task) = self.tasks.iter_mut().find(|t| t.id == task_id) { │ task.status = status.clone(); │ if matches!(status, TaskStatus::Running) { │ task.started_at = Some(Utc::now().timestamp()); │ } │ if matches!(status, TaskStatus::Completed | TaskStatus::Failed) { │ task.ended_at = Some(Utc::now().timestamp()); │ } │ ⋮... │ pub fn set_instance_state(&mut self, instance_id: Uuid, state: serde_json::Value) -> bool { │ if self.instances.iter().any(|i| i.id == instance_id) { │ self.instance_states.insert(instance_id, state); │ true │ } else { │ false │ } ⋮... │ pub fn get_instance_state(&self, instance_id: Uuid) -> Option { │ self.instance_states.get(&instance_id).cloned() ⋮... tests/agent/manager_impl.rs: ⋮... │async fn setup_test_db() -> PgPool { │ let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set"); │ PgPool::connect(&database_url).await.unwrap() ⋮... tests/agent/mod.rs: │pub mod core; │pub mod manager; │pub mod manager_impl; │pub mod manager_comprehensive; │pub mod nostr; tests/agent/nostr.rs: ⋮... │fn create_agent_status_event(agent: &Agent, instance: &AgentInstance) -> Event { │ Event { │ id: "a6b6c6d6e6f6".into(), │ pubkey: agent.pubkey.clone(), │ created_at: Utc::now().timestamp(), │ kind: 30001, │ tags: vec![ │ vec!["d".into(), "agent_status".into()], │ vec!["p".into(), agent.pubkey.clone()], │ ], ⋮... tests/nostr/mod.rs: │mod database; │mod event; │mod subscription;
