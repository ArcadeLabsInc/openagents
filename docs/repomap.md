src/agents/agent.rs: ⋮... │pub enum InstanceStatus { │ Starting, │ Running, │ Paused, │ Stopping, │ Stopped, │ Error, ⋮... │pub enum PlanStatus { │ Created, │ InProgress, │ Completed, │ Failed, │ Cancelled, ⋮... │pub enum TaskStatus { │ Pending, │ Scheduled, │ Running, │ Completed, │ Failed, │ Cancelled, ⋮... src/agents/manager.rs: ⋮... │pub struct AgentManager { │ pool: PgPool, │ instances: Arc>>, │ instance*states: Arc>>, │ instance_metrics: Arc>>, ⋮... │impl AgentManager { │ pub fn new(pool: PgPool) -> Self { │ Self { │ pool, │ instances: Arc::new(RwLock::new(HashMap::new())), │ instance_states: Arc::new(RwLock::new(HashMap::new())), │ instance_metrics: Arc::new(RwLock::new(HashMap::new())), │ } │ } │ │ // Agent Management │ pub async fn create_agent( │ &self, │ name: &str, │ description: &str, │ pubkey: &str, │ config: serde_json::Value, ⋮... │ pub async fn get_agent(&self, id: Uuid) -> Result { │ let record = sqlx::query!( │ r#" │ SELECT id, name, description, pubkey, enabled, config, │ EXTRACT(EPOCH FROM created_at)::BIGINT as created_at │ FROM agents WHERE id = $1 │ "#, │ id │ ) │ .fetch_one(&self.pool) ⋮... │ pub async fn create_instance(&self, agent_id: Uuid) -> Result { │ // Get agent and validate │ let agent = self.get_agent(agent_id).await?; │ if !agent.enabled { │ return Err(anyhow!("Agent is disabled")); │ } │ │ // Check instance limits │ let instance_count = sqlx::query!( │ "SELECT COUNT(\*) as count FROM agent_instances WHERE agent_id = $1 AND status != 'Stopp ⋮... │ pub async fn set_instance_state( │ &self, │ instance_id: Uuid, │ state: serde_json::Value, ⋮... │ pub async fn update_instance_metrics( │ &self, │ instance_id: Uuid, │ metrics: serde_json::Value, ⋮... │ fn validate_agent_config(&self, config: serde_json::Value) -> Result { │ let mut config = config │ .as_object() │ .ok_or(anyhow!("Invalid config format"))? │ .clone(); │ │ // Ensure required fields with defaults │ if !config.contains_key("version") { │ config.insert("version".into(), json!("1.0.0")); │ } ⋮... src/configuration.rs: ⋮... │pub struct DatabaseSettings { │ #[serde(default)] │ pub username: String, │ #[serde(default = "default_password")] │ pub password: Secret, │ #[serde(default = "default_port")] │ pub port: u16, │ #[serde(default)] │ pub host: String, │ #[serde(default)] ⋮... │impl DatabaseSettings { │ pub fn connect_options(&self) -> PgConnectOptions { │ // First check for DATABASE_URL │ if let Ok(database_url) = std::env::var("DATABASE_URL") { │ info!("Using DATABASE_URL from environment"); │ │ let url = match Url::parse(&database_url) { │ Ok(url) => { │ debug!("Successfully parsed DATABASE_URL"); │ url │ } ⋮... │pub fn get_configuration() -> Result { │ info!("Loading configuration..."); │ │ let base_path = std::env::current_dir() │ .expect("Failed to determine current directory") │ .join("configuration"); │ │ let environment: AppEnvironment = std::env::var("APP_ENVIRONMENT") │ .unwrap_or_else(|*| { │ info!("APP*ENVIRONMENT not set, defaulting to 'local'"); ⋮... │pub enum AppEnvironment { │ Local, │ Production, ⋮... │impl AppEnvironment { │ pub fn as_str(&self) -> &'static str { │ match self { │ AppEnvironment::Local => "local", │ AppEnvironment::Production => "production", │ } │ } ⋮... │impl TryFrom for AppEnvironment { │ type Error = String; │ │ fn try_from(s: String) -> Result { │ match s.to_lowercase().as_str() { │ "local" => Ok(Self::Local), │ "production" => Ok(Self::Production), │ other => { │ error!("Invalid environment: {}", other); │ Err(format!( ⋮... src/lib.rs: ⋮... │pub mod database; ⋮... │pub async fn generate_repomap( │ State(service): State>, │ Form(req): Form, ⋮... src/nostr/db.rs: ⋮... │pub struct Database { │ pool: Pool, ⋮... src/nostr/event.rs: ⋮... │pub struct Event { │ pub id: String, │ pub pubkey: String, │ pub created_at: i64, │ pub kind: i32, │ pub tags: Vec>, │ pub content: String, │ pub sig: String, │ #[serde(skip)] │ pub tagidx: Option>>, ⋮... │impl Event { │ pub fn validate(&self) -> Result<(), &'static str> { │ // Validate event format and signature │ let canonical = self.to_canonical().ok_or("Could not canonicalize event")?; │ │ // Compute SHA256 of canonical form │ let digest: sha256::Hash = sha256::Hash::hash(canonical.as_bytes()); │ let hex_digest = format!("{digest:x}"); │ │ // Verify ID matches computed hash │ if self.id != hex_digest { ⋮... │ pub fn to_canonical(&self) -> Option { │ let elements = vec![ │ serde_json::Value::Number(0.into()), // id placeholder │ serde_json::Value::String(self.pubkey.clone()), │ serde_json::Value::Number(self.created_at.into()), │ serde_json::Value::Number(self.kind.into()), │ self.tags_to_canonical(), │ serde_json::Value::String(self.content.clone()), │ ]; │ ⋮... │ pub fn build_index(&mut self) { │ if self.tags.is_empty() { │ return; │ } │ │ let mut idx: HashMap> = HashMap::new(); │ │ for tag in self.tags.iter().filter(|t| t.len() > 1) { │ if let Some(tag_char) = tag.first().and_then(|s| s.chars().next()) { │ if let Some(tag_val) = tag.get(1) { ⋮... src/nostr/mod.rs: │pub mod axum_relay; │pub mod db; │pub mod event; │pub mod subscription; src/server/admin/mod.rs: │pub mod middleware; │pub mod routes; src/server/admin/routes.rs: ⋮... │pub fn admin_routes() -> axum::Router { │ // Create shared solver service and WebSocket state │ let solver_service = Arc::new(SolverService::new()); │ let ws_state = Arc::new(SolverWsState::new(solver_service.clone())); │ │ axum::Router::new() │ .route("/", axum::routing::get(admin_dashboard)) │ .route("/login", axum::routing::get(admin_login)) │ .route("/login", axum::routing::post(admin_login_post)) │ .route("/stats", axum::routing::get(admin_stats)) ⋮... src/server/services/deepseek.rs: ⋮... │pub struct DeepSeekService { │ client: Client, │ api_key: String, │ base_url: String, ⋮... │impl DeepSeekService { │ pub fn new(api_key: String) -> Self { │ Self { │ client: Client::new(), │ api_key, │ base_url: "https://api.deepseek.com".to_string(), │ } │ } │ │ pub fn with_base_url(api_key: String, base_url: String) -> Self { ⋮... │ pub async fn chat( │ &self, │ prompt: String, │ use_reasoner: bool, ⋮... │ pub async fn chat_stream( │ &self, │ prompt: String, │ use_reasoner: bool, ⋮... │ async fn chat_internal( │ &self, │ prompt: String, │ use_reasoner: bool, │ stream: bool, ⋮... src/server/services/github.rs: ⋮... │pub struct GitHubService { │ client: Client, │ api_key: String, │ base_url: String, ⋮... │impl GitHubService { │ pub fn new(api_key: String) -> Self { │ Self { │ client: Client::new(), │ api_key, │ base_url: "https://api.github.com".to_string(), │ } │ } │ │ pub fn new_with_base_url(api_key: String, base_url: String) -> Self { ⋮... │ pub async fn get_issue( │ &self, │ owner: &str, │ repo: &str, │ issue_number: i32, ⋮... src/server/services/github_types.rs: ⋮... │pub struct Issue { │ pub title: String, │ pub body: String, │ pub number: i32, │ pub state: String, ⋮... │pub struct Repository { │ pub name: String, │ pub owner: String, │ pub description: Option, ⋮... src/server/services/openrouter.rs: ⋮... │pub struct OpenRouterService { │ client: Client, │ api_key: String, │ base_url: String, ⋮... │impl OpenRouterService { │ pub fn new(api_key: String) -> Self { │ let client = Client::builder() │ .timeout(Duration::from_secs(120)) // 2 minute timeout │ .build() │ .expect("Failed to create HTTP client"); │ │ Self { │ client, │ api_key, ⋮... │ pub async fn inference_stream(&self, prompt: String) -> Result { │ info!("Making streaming inference request to OpenRouter"); │ // info!("Sending prompt to OpenRouter: {}", prompt); │ │ let request_body = serde_json::json!({ │ "model": "deepseek/deepseek-chat", │ "messages": [{ │ "role": "user", │ "content": prompt │ }], ⋮... src/server/services/repomap.rs: ⋮... │pub struct RepomapService { │ client: Client, │ api_key: String, │ base_url: String, ⋮... │impl RepomapService { │ pub fn new(api_key: String) -> Self { │ Self { │ client: Client::new(), │ api_key, │ base_url: "https://aider.openagents.com".to_string(), │ } │ } │ │ pub fn with_base_url(api_key: String, base_url: String) -> Self { ⋮... │ pub async fn generate_repomap(&self, repo_url: String) -> Result { │ info!("Making request to aider service for repo: {}", repo_url); │ │ let url = format!("{}/api/v1/repomap/generate", self.base_url); │ let response = self │ .client │ .post(&url) │ .header("Content-Type", "application/json") │ .header("X-API-Key", &self.api_key) │ .json(&serde_json::json!({ ⋮... src/server/services/solver/mod.rs: ⋮... │pub struct SolverService { │ repomap_service: Arc, │ deepseek_service: Arc, │ github_service: Arc, ⋮... │impl SolverService { │ pub fn new() -> Self { │ let aider_api_key = std::env::var("AIDER_API_KEY").expect("AIDER_API_KEY must be set"); │ let deepseek_api_key = │ std::env::var("DEEPSEEK_API_KEY").expect("DEEPSEEK_API_KEY must be set"); │ let github_token = std::env::var("GITHUB_TOKEN").expect("GITHUB_TOKEN must be set"); │ │ Self { │ repomap_service: Arc::new(RepomapService::new(aider_api_key)), │ deepseek_service: Arc::new(DeepSeekService::new(deepseek_api_key)), ⋮... │ pub async fn solve_issue(&self, issue_url: String) -> Result { │ // Create a temporary broadcast channel for this request │ let (tx, *) = broadcast::channel(100); │ self.solve*issue_with_ws(issue_url, tx).await ⋮... src/server/services/solver/ws/mod.rs: ⋮... │impl super::SolverService { │ pub(crate) async fn solve_issue_with_ws( │ &self, │ issue_url: String, │ update_tx: broadcast::Sender, │ ) -> Result { │ info!("Processing issue: {}", issue_url); │ │ // Send initial progress update │ let * = update_tx.send(SolverUpdate::Progress { ⋮... src/server/services/solver/ws/types.rs: ⋮... │pub enum SolverStage { │ Init, │ Repomap, │ Analysis, │ Solution, │ PR, ⋮... src/server/ws/handlers/chat.rs: ⋮... │pub struct ChatHandler { │ ws_state: Arc, ⋮... │impl ChatHandler { │ pub fn new(ws_state: Arc) -> Self { │ Self { ws_state } │ } │ │ async fn process_message( │ &self, │ content: String, │ ) -> Result> { │ info!("Processing message: {}", content); │ ⋮... │impl MessageHandler for ChatHandler { │ type Message = ChatMessage; │ │ async fn handle_message( │ &self, │ msg: Self::Message, │ conn_id: String, │ ) -> Result<(), Box> { │ info!("Handling chat message: {:?}", msg); │ match msg { ⋮... src/server/ws/handlers/mod.rs: ⋮... │pub trait MessageHandler { │ type Message; │ │ async fn handle_message( │ &self, │ msg: Self::Message, │ conn_id: String, │ ) -> Result<(), Box>; │ async fn broadcast(&self, msg: Self::Message) -> Result<(), Box>; ⋮... src/server/ws/handlers/solver.rs: ⋮... │pub struct SolverHandler { │ // Add fields for solver dependencies ⋮... │impl MessageHandler for SolverHandler { │ type Message = SolverMessage; │ │ async fn handle_message( │ &self, │ \_msg: Self::Message, │ \_conn_id: String, │ ) -> Result<(), Box> { │ // TODO: Implement solver message handling │ Ok(()) ⋮... src/server/ws/transport.rs: ⋮... │impl WebSocketState { │ pub fn new() -> Arc { │ Arc::new(Self { │ connections: Arc::new(RwLock::new(HashMap::new())), │ }) │ } │ │ pub fn create_handlers( │ ws_state: Arc, │ ) -> (Arc, Arc) { ⋮... │ pub async fn send_to( │ &self, │ conn_id: &str, │ msg: &str, ⋮... tests/agent/manager.rs: ⋮... │impl MockAgentManager { │ pub fn new() -> Self { │ Self { │ agents: Vec::new(), │ instances: Vec::new(), │ plans: Vec::new(), │ tasks: Vec::new(), │ instance_states: HashMap::new(), │ instance_counts: HashMap::new(), │ } ⋮... │ pub fn create_instance(&mut self, agent_id: Uuid) -> AgentInstance { │ // Check resource limits │ if let Some(agent) = self.agents.iter().find(|a| a.id == agent_id) { │ let current_count = self.instance_counts.get(&agent_id).unwrap_or(&0); │ │ if let Some(max_instances) = agent.config.get("max_instances").and_then(|v| v.as_u64()) │ { │ if \*current_count >= max_instances as usize { │ return AgentInstance { │ id: Uuid::new_v4(), ⋮... │ pub fn create_task(&mut self, plan_id: Uuid, instance_id: Uuid, task_type: &str) -> Task { │ let task = Task { │ id: Uuid::new_v4(), │ plan_id, │ instance_id, │ task_type: task_type.into(), │ status: TaskStatus::Pending, │ priority: 1, │ input: json!({}), │ output: None, ⋮... │ pub fn set_instance_state(&mut self, instance_id: Uuid, state: serde_json::Value) -> bool { │ if self.instances.iter().any(|i| i.id == instance_id) { │ self.instance_states.insert(instance_id, state); │ true │ } else { │ false │ } ⋮... tests/agent/nostr.rs: ⋮... │fn create_agent_status_event(agent: &Agent, instance: &AgentInstance) -> Event { │ Event { │ id: "a6b6c6d6e6f6".into(), │ pubkey: agent.pubkey.clone(), │ created_at: Utc::now().timestamp(), │ kind: 30001, │ tags: vec![ │ vec!["d".into(), "agent_status".into()], │ vec!["p".into(), agent.pubkey.clone()], │ ], ⋮... tests/nostr/mod.rs: │mod database; │mod event; │mod subscription;
