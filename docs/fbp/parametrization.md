# Parametrization of Reusable Components

## On IIP

###Excerpt:

> I would now like to describe the way generalized FBP components are made reusable, using one additional, very powerful
> FBP mechanism, the "Initial Information Packet" or "IIP". IIPs were developed by E. Lawton of my old department at IBM
> in response to some of the problems we ran into using DFDM's parameter facility.
>
> Let's say you have built a component like one of the ones described in the previous chapters. Let's call it "Select".
> It should be clear from the foregoing that this component can be used in a variety of contexts, as long as it is sent
> data in the format it expects. Because a component communicates with the outside world only through data being sent to
> or received from its ports, it can be held in object form, and never modified. Such reuse is often called "black box"
> reuse, to suggest the idea that the user cannot see the insides of the component. In addition, since the "black box"
> never needs to be modified, once its developer gets it working, it can be relied on to work correctly in any context.
> This is the converse of "white box" or "clear box" (source level) reuse, which is what most so-called reuse tools
> provide today. This type of reuse is easy to provide, but in my view doesn't buy its users much. It may reduce the
> cost
> of developing new code, but the amount of net new code which has to be maintained still increases. Furthermore, if a
> bug
> is found in the reused code, there is no easy way to tell whether it is safe to fix all instances of it - if you can
> even find them (with some reuse tools you can't even do that).
> We will of course have to tell our black box Select component which fields to select on, as, otherwise, it will only
> be
> able to select on whichever fields were hard-wired into it. Suppose we want to tell it that it is to do its selecting
> on
> the contents of a 6-byte field starting at offset 23 in each incoming IP, and also want to give it a list of
> acceptable
> field values. In classical programming, we do this kind of thing by having the calling program specify parameters. In
> FBP we do something similar, but there is no user-written calling program in which to specify the parameters. Instead
> there is a way for the application designer to specify this information, right in the application structure
> definition.
> This mechanism is called an Initial Information Packet (IIP). We also need an additional port on the component (let's
> call it OPTIONS - it can have any name we want). An IIP can be generated as part of the structure and associated with
> the chosen port.
>
> Once the process is started, an IIP is turned into an ordinary IP by the component issuing a "receive" service call
> against the port the IIP is connected to. This has the added advantage that the OPTIONS port can also be fed by an
> upstream process instead of an IIP, so component options can either be decided at structure-building time or deferred
> until execution time, without any modification of the component being required. What the component sees when it does
> its
> receive from the OPTIONS port is an ordinary IP. In what follows, we will sometimes refer to this as an "options IP" -
> options IPs may start out life as IIPs or may be generated by upstream processes, but their function is primarily to
> control execution, rather than to carry data (obviously this is not a hard and fast distinction, and you may find a
> need
> for IPs which combine both functions).
>
> One last point about options IPs: a major decision for the component designer is whether to make them free-form or
> give them a fixed layout - the former will generally be easier to specify, but is going to cost more processing time
> to
> scan for delimiters, convert numeric values, etc. However, since this processing is usually done just once, at the
> beginning of the run, it may not be significant in the context of total processing time. THREADS opted for free-form
> IIPs for its "off the shelf" components because of the ease of use factor. One other thing you should consider if you
> choose to use free-form IIPs is that you will need to decide on delimiter conventions, e.g. you might opt for commas
> or
> blanks, and you might decide to use brackets to group together sets of option values. This in turn means some
> convention
> will be needed for specifying character strings which might contain delimiter characters as valid values (the old "
> quotes within quoted strings" problem).

### Summary

This section covers the concept of making Flow-Based Programming (FBP) components reusable through the mechanism known
as the "Initial Information Packet" (IIP), introduced by E. Lawton at IBM. It addresses the limitations encountered with
the parameter facility in DFDM.

## Black Box Reuse

- **Concept**: Components, once developed, operate as "black boxes" that do not require modification for reuse,
  contrasting with "white box" or "clear box" reuse which involves source-level code sharing.
- **Advantages**: Reliability and reduction in maintenance, as the component's internal workings are opaque and
  unchanged across different applications.

## Initial Information Packet (IIP)

- **Definition**: A mechanism for specifying component parameters outside of a user-written calling program. It enables
  the application designer to define component behavior directly in the application structure.
- **Usage**: An IIP is associated with a component's port (e.g., an OPTIONS port) and is converted into a standard
  Information Packet (IP) upon the component's execution, allowing for dynamic option specification without component
  modification.

## Options IP

- **Function**: Primarily controls execution. It originates either as an IIP or from upstream processes, blurring the
  lines between control and data packets.
- **Design Considerations**: The choice between free-form and fixed-layout IPs impacts processing time and ease of
  specification. THREADS uses free-form IIPs for flexibility, requiring conventions for delimiters and character
  strings.

This summary encapsulates the strategy for enhancing the reusability of FBP components through initial information
packets, emphasizing the shift towards modular, maintainable, and adaptable software design.
