use crate::solver::context::SolverContext;
use anyhow::Result;
use std::fs;
use tracing::{debug, error, info};

pub async fn handle_solution(
    issue_number: i32,
    title: &str,
    description: &str,
    plan: &str,
    repo_map: &str,
    ollama_url: &str,
) -> Result<()> {
    let context = SolverContext::new()?;

    // Generate file list
    info!("Generating file list...");
    let (files, reasoning) = context
        .generate_file_list(title, description, repo_map, ollama_url)
        .await?;
    debug!("Files to modify: {:?}", files);
    debug!("Reasoning: {}", reasoning);

    // Collect all changes and their reasoning
    let mut all_changes = Vec::new();
    let mut all_reasoning = String::new();

    // For each file, generate and apply changes
    for file in files {
        info!("Processing file: {}", file);

        // Read file content
        let content = fs::read_to_string(&file)?;

        // Generate changes
        let (changes, reasoning) = context
            .generate_changes(&file, &content, title, description, ollama_url)
            .await?;
        debug!("Changes for {}: {:?}", file, changes);
        debug!("Reasoning: {}", reasoning);

        // Apply changes
        context.apply_changes(&changes)?;

        // Collect changes and reasoning
        all_changes.extend(changes);
        if !all_reasoning.is_empty() {
            all_reasoning.push_str("\n\n");
        }
        all_reasoning.push_str(&reasoning);
    }

    // Create PR with descriptive title
    if !all_changes.is_empty() {
        let pr_context = format!(
            "Changes:\n{}\n\nReasoning:\n{}\n\nPlan:\n{}\n\nOriginal Issue:\n{}\n{}",
            all_changes
                .iter()
                .map(|c| format!(
                    "- {} ({})",
                    c.path,
                    c.reason.as_ref().unwrap_or(&"No reason provided".to_string())
                ))
                .collect::<Vec<_>>()
                .join("\n"),
            all_reasoning,
            plan,
            title,
            description
        );

        // Create branch and PR
        let branch_name = format!("solver/{}", issue_number);
        context.create_branch(&branch_name, "main").await?;

        // Create PR with generated title
        context
            .create_pull_request(
                &branch_name,
                "main",
                &pr_context,
                &format!(
                    "Resolves #{}\n\n### Changes\n{}\n\n### Reasoning\n{}\n\n### Generated by OpenAgents Solver",
                    issue_number, 
                    all_changes
                        .iter()
                        .map(|c| format!(
                            "- {} ({})",
                            c.path,
                            c.reason.as_ref().unwrap_or(&"No reason provided".to_string())
                        ))
                        .collect::<Vec<_>>()
                        .join("\n"),
                    all_reasoning
                ),
                issue_number,
            )
            .await?;
    } else {
        error!("No changes were generated");
    }

    // Clean up
    context.cleanup()?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[tokio::test]
    async fn test_handle_solution() {
        let temp_dir = tempdir().unwrap();
        let test_file = temp_dir.path().join("test.rs");
        fs::write(&test_file, "// Original content").unwrap();

        let context = SolverContext::new().unwrap();
        let result = handle_solution(
            123,
            "Add multiply function",
            "Add a function that multiplies two numbers",
            "Implementation plan",
            "Repository map",
            "test_url",
        )
        .await;

        assert!(result.is_ok());
    }
}